-- MatchaLinoria (Drawing-based Linoria-style UI for Matcha LuaVM)
-- Author: ChatGPT (adapted to provided Drawing + input API)
-- Features: Create window, tabs, sections, buttons, toggles, sliders, dropdowns, color picker, textbox
-- Input: Players.LocalPlayer:GetMouse(), ismouse1pressed(), iskeypressed(vk)
-- Toggle UI: Delete key (VK 0x2E)

-- ---------- Configuration & Helpers ----------
local Players = (pcall(function() return game:GetService("Players") end) and game:GetService("Players")) or nil
local LocalPlayer = Players and Players.LocalPlayer
local Mouse = (LocalPlayer and pcall(function() return LocalPlayer:GetMouse() end)) and LocalPlayer:GetMouse() or { X = 0, Y = 0 }
local TaskWait = task and task.wait or wait

-- VM input helpers assumed present:
-- ismouse1pressed() -> bool
-- iskeypressed(vk:int) -> bool

-- Basic theme (Linoria default)
local DefaultTheme = {
    Background = Color3.fromRGB(26,26,28),
    Panel = Color3.fromRGB(34,34,36),
    Accent = Color3.fromRGB(0,150,255),
    Text = Color3.fromRGB(230,230,230),
    SubText = Color3.fromRGB(160,160,160),
    Hover = Color3.fromRGB(46,46,48),
    Disabled = Color3.fromRGB(60,60,62)
}

-- Drawing creation wrapper
local CreatedDrawings = {}
local function newDraw(kind, props)
    local ok, obj = pcall(function() return Drawing.new(kind) end)
    if not ok or not obj then return nil end
    for k,v in pairs(props or {}) do pcall(function() obj[k] = v end) end
    table.insert(CreatedDrawings, obj)
    return obj
end

local function removeDraw(obj)
    if not obj then return end
    pcall(function() obj:Remove() end)
    for i,v in ipairs(CreatedDrawings) do
        if v == obj then table.remove(CreatedDrawings,i); break end
    end
end

local function cleanupAll()
    for _,d in ipairs(CreatedDrawings) do pcall(function() d:Remove() end) end
    CreatedDrawings = {}
end

local function clamp(n,a,b) return math.max(a, math.min(b, n)) end
local function insideRect(x,y,w,h, mx, my)
    return mx >= x and mx <= x + w and my >= y and my <= y + h
end

-- VK mapping helpers for basic typing
local VK = {
    BACKSPACE = 0x08,
    TAB = 0x09,
    ENTER = 0x0D,
    SHIFT = 0x10,
    CTRL = 0x11,
    ALT = 0x12,
    PAUSE = 0x13,
    CAPS = 0x14,
    ESC = 0x1B,
    SPACE = 0x20,
    PAGEUP = 0x21,
    PAGEDOWN = 0x22,
    END = 0x23,
    HOME = 0x24,
    LEFT = 0x25,
    UP = 0x26,
    RIGHT = 0x27,
    DOWN = 0x28,
    INSERT = 0x2D,
    DELETE = 0x2E
}
-- letters A-Z: 0x41 - 0x5A ; digits 0-9: 0x30 - 0x39

-- ---------- UI Library ----------
local MatchaLinoria = {}
MatchaLinoria.__index = MatchaLinoria
MatchaLinoria.Theme = {}
for k,v in pairs(DefaultTheme) do MatchaLinoria.Theme[k] = v end

function MatchaLinoria:CreateWindow(opts)
    opts = opts or {}
    local win = {}
    win.Title = opts.Title or "MatchaLinoria"
    win.Position = opts.Position or Vector2.new(200,120)
    win.Size = opts.Size or Vector2.new(560, 420)
    win.Visible = true
    win.Theme = {}
    for k,v in pairs(MatchaLinoria.Theme) do win.Theme[k] = v end
    if opts.Theme then for k,v in pairs(opts.Theme) do win.Theme[k] = v end end

    -- internal state
    win._tabs = {}
    win._pages = {}
    win._activePage = nil
    win._running = true
    win._mousePrev = false
    win._keyPrev = {}
    win._focusedTextBox = nil
    win._zIndex = 1

    -- Drawing objects
    -- Background panel
    local bg = newDraw("Square", {
        Color = win.Theme.Background,
        Transparency = 1,
        Filled = true,
        Position = win.Position,
        Size = win.Size,
        Visible = true,
        ZIndex = win._zIndex
    })
    -- Header bar
    local header = newDraw("Square", {
        Color = win.Theme.Panel,
        Transparency = 1,
        Filled = true,
        Position = Vector2.new(win.Position.X, win.Position.Y),
        Size = Vector2.new(win.Size.X, 28),
        Visible = true,
        ZIndex = win._zIndex + 1
    })
    local titleText = newDraw("Text", {
        Text = win.Title,
        Color = win.Theme.Text,
        Position = Vector2.new(win.Position.X + 10, win.Position.Y + 5),
        Size = 18,
        Outline = true,
        Visible = true,
        ZIndex = win._zIndex + 2
    })
    local closeText = newDraw("Text", {
        Text = "X",
        Color = win.Theme.Text,
        Position = Vector2.new(win.Position.X + win.Size.X - 22, win.Position.Y + 4),
        Size = 18,
        Outline = true,
        Visible = true,
        ZIndex = win._zIndex + 2
    })

    -- Tab button holder (we draw tab rects later)
    win._drawObjects = {
        bg = bg, header = header, titleText = titleText, closeText = closeText
    }

    -- layout helpers
    local contentOrigin = Vector2.new(win.Position.X + 10, win.Position.Y + 38)

    -- helpers to update positions when moving window
    local function repositionAll()
        -- update bg/header/title/close
        if bg  then pcall(function() bg.Position = win.Position; bg.Size = win.Size end) end
        if header then pcall(function() header.Position = Vector2.new(win.Position.X, win.Position.Y); header.Size = Vector2.new(win.Size.X,28) end) end
        if titleText then pcall(function() titleText.Position = Vector2.new(win.Position.X + 10, win.Position.Y + 5) end) end
        if closeText then pcall(function() closeText.Position = Vector2.new(win.Position.X + win.Size.X - 22, win.Position.Y + 4) end) end

        contentOrigin = Vector2.new(win.Position.X + 10, win.Position.Y + 38)
        -- reposition tabs
        for i,tab in ipairs(win._tabs) do
            local bx = win.Position.X + 8 + (i-1)*100
            pcall(function() tab.drawRect.Position = Vector2.new(bx, win.Position.Y + 32) end)
            pcall(function() tab.drawText.Position = Vector2.new(bx + 8, win.Position.Y + 34) end)
            -- reposition page elements
            if tab.page then
                for sIndex,section in ipairs(tab.page.sections) do
                    pcall(function() section.headerRect.Position = Vector2.new(contentOrigin.X, contentOrigin.Y + section.yOffset) end)
                    pcall(function() section.headerText.Position = Vector2.new(contentOrigin.X + 8, contentOrigin.Y + section.yOffset + 4) end)
                    for _,it in ipairs(section.items) do
                        if it.Type == "Button" then
                            pcall(function()
                                it.Rect.Position = Vector2.new(contentOrigin.X + 6, contentOrigin.Y + it._y)
                                it.Text.Position = Vector2.new(contentOrigin.X + 12, contentOrigin.Y + it._y + 6)
                            end)
                        elseif it.Type == "Toggle" then
                            pcall(function()
                                it.Box.Position = Vector2.new(contentOrigin.X + 8, contentOrigin.Y + it._y + 4)
                                it.Label.Position = Vector2.new(contentOrigin.X + 8 + it.Box.Size.X + 8, contentOrigin.Y + it._y + 4)
                            end)
                        elseif it.Type == "Slider" then
                            pcall(function()
                                it.Bg.Position = Vector2.new(contentOrigin.X + 12, contentOrigin.Y + it._y + 18)
                                it.Fill.Position = it.Bg.Position
                                it.Label.Position = Vector2.new(it.Bg.Position.X, it.Bg.Position.Y - 18)
                            end)
                        elseif it.Type == "Dropdown" then
                            pcall(function()
                                it.Box.Position = Vector2.new(contentOrigin.X + 12, contentOrigin.Y + it._y)
                                it.Label.Position = Vector2.new(contentOrigin.X + 18, contentOrigin.Y + it._y + 4)
                                -- option rects reposition if expanded
                                if it.Expanded and it.OptionRects then
                                    for idx,optRect in ipairs(it.OptionRects) do
                                        optRect.rect.Position = Vector2.new(it.Box.Position.X, it.Box.Position.Y + idx*26)
                                        optRect.txt.Position = Vector2.new(it.Box.Position.X + 6, it.Box.Position.Y + idx*26 + 4)
                                    end
                                end
                            end)
                        elseif it.Type == "ColorPicker" then
                            pcall(function()
                                it.Preview.Position = Vector2.new(contentOrigin.X + 12, contentOrigin.Y + it._y)
                                it.Title.Position = Vector2.new(it.Preview.Position.X + 56, it.Preview.Position.Y + 2)
                                -- sliders reposition
                                for iS,sl in ipairs({it.R, it.G, it.B}) do
                                    sl.Bg.Position = Vector2.new(it.Preview.Position.X + 56, it.Preview.Position.Y + (iS-1)*28)
                                    sl.Fill.Position = sl.Bg.Position
                                    sl.Label.Position = Vector2.new(sl.Bg.Position.X, sl.Bg.Position.Y - 18)
                                end
                            end)
                        elseif it.Type == "TextBox" then
                            pcall(function()
                                it.Box.Position = Vector2.new(contentOrigin.X + 12, contentOrigin.Y + it._y)
                                it.Text.Position = Vector2.new(contentOrigin.X + 18, contentOrigin.Y + it._y + 4)
                            end)
                        end
                    end
                end
            end
        end
    end

    -- --------- Public API: AddTab, AddSection, and element creators ----------
    function win:AddTab(name)
        local tab = { name = name, sections = {}, items = {} }
        local index = #win._tabs + 1
        local bx = win.Position.X + 8 + (index-1)*100
        local btnRect = newDraw("Square", {
            Color = win.Theme.Panel, Transparency = 1, Filled = true,
            Position = Vector2.new(bx, win.Position.Y + 32), Size = Vector2.new(92, 20),
            Visible = true, ZIndex = win._zIndex + 5
        })
        local btnText = newDraw("Text", {
            Text = name, Color = win.Theme.Text,
            Position = Vector2.new(bx + 8, win.Position.Y + 34), Size = 14,
            Outline = true, Visible = true, ZIndex = win._zIndex + 6
        })
        tab.drawRect = btnRect
        tab.drawText = btnText

        tab.page = { name = name, sections = {} }
        win._pages[name] = tab.page
        table.insert(win._tabs, tab)

        -- auto-select first tab
        if not win._activePage then
            win._activePage = tab.page
            btnRect.Color = win.Theme.Accent
        end

        return tab.page
    end

    function win:AddSection(page, title)
        page = page or win._activePage
        if not page then page = win:AddTab("Page") end
        local section = { Title = title, items = {}, yOffset = 0, _cursor = 0 }
        -- compute yOffset: sum of previous sections heights
        local y = 0
        for _,s in ipairs(page.sections) do y = y + 34 + (#s.items * 36) end
        section.yOffset = y
        -- header rect & text
        local headerRect = newDraw("Square", {
            Color = win.Theme.Panel, Transparency = 1, Filled = true,
            Position = Vector2.new(contentOrigin.X, contentOrigin.Y + section.yOffset),
            Size = Vector2.new(win.Size.X - 20, 26), Visible = true, ZIndex = win._zIndex + 4
        })
        local headerText = newDraw("Text", {
            Text = title, Color = win.Theme.Text,
            Position = Vector2.new(contentOrigin.X + 8, contentOrigin.Y + section.yOffset + 4),
            Size = 16, Outline = true, Visible = true, ZIndex = win._zIndex + 5
        })
        section.headerRect = headerRect
        section.headerText = headerText
        section._origin = contentOrigin
        section._y = section.yOffset
        table.insert(page.sections, section)
        return section
    end

    function win:AddButton(section, label, callback)
        section = section or (win._activePage and win._activePage.sections[1])
        if not section then return end
        local y = section._y + (#section.items * 36) + 8
        local x = contentOrigin.X
        local w = win.Size.X - 40
        local h = 28
        local rect = newDraw("Square", {
            Color = win.Theme.Panel, Transparency = 1, Filled = true,
            Position = Vector2.new(x + 6, contentOrigin.Y + y), Size = Vector2.new(w, h),
            Visible = true, ZIndex = win._zIndex + 6
        })
        local txt = newDraw("Text", {
            Text = label, Color = win.Theme.Text,
            Position = Vector2.new(x + 12, contentOrigin.Y + y + 6), Size = 15,
            Outline = true, Visible = true, ZIndex = win._zIndex + 7
        })
        local item = { Type = "Button", Rect = rect, Text = txt, X = x + 6, Y = contentOrigin.Y + y, W = w, H = h, Callback = callback, _y = y }
        table.insert(section.items, item)
        return item
    end

    function win:AddToggle(section, label, default, callback)
        section = section or (win._activePage and win._activePage.sections[1])
        if not section then return end
        default = default and true or false
        local y = section._y + (#section.items * 36) + 8
        local x = contentOrigin.X
        local boxSize = 20
        local box = newDraw("Square", {
            Color = default and win.Theme.Accent or win.Theme.Panel,
            Transparency = 1, Filled = true,
            Position = Vector2.new(x + 8, contentOrigin.Y + y + 4),
            Size = Vector2.new(boxSize, boxSize), Visible = true, ZIndex = win._zIndex + 6
        })
        local lbl = newDraw("Text", {
            Text = label, Color = win.Theme.Text,
            Position = Vector2.new(x + 8 + boxSize + 8, contentOrigin.Y + y + 4), Size = 15,
            Outline = true, Visible = true, ZIndex = win._zIndex + 7
        })
        local item = { Type = "Toggle", Box = box, Label = lbl, State = default, Callback = callback, X = x + 8, Y = contentOrigin.Y + y + 4, W = boxSize, H = boxSize, _y = y }
        table.insert(section.items, item)
        return item
    end

    function win:AddSlider(section, label, min, max, default, step, callback)
        section = section or (win._activePage and win._activePage.sections[1])
        if not section then return end
        min = min or 0; max = max or 100; default = default or min; step = step or 1
        local y = section._y + (#section.items * 46) + 8
        local x = contentOrigin.X
        local width = win.Size.X - 60
        local barX = x + 12
        local barY = contentOrigin.Y + y + 18

        local bg = newDraw("Square", {
            Color = win.Theme.Panel, Transparency = 1, Filled = true,
            Position = Vector2.new(barX, barY), Size = Vector2.new(width, 8), Visible = true, ZIndex = win._zIndex + 6
        })
        local fillPct = clamp((default - min) / (max - min), 0, 1)
        local fill = newDraw("Square", {
            Color = win.Theme.Accent, Transparency = 1, Filled = true,
            Position = Vector2.new(barX, barY), Size = Vector2.new(width * fillPct, 8), Visible = true, ZIndex = win._zIndex + 7
        })
        local labelText = newDraw("Text", {
            Text = label .. " : " .. tostring(default),
            Color = win.Theme.Text, Position = Vector2.new(barX, barY - 18),
            Size = 14, Outline = true, Visible = true, ZIndex = win._zIndex + 7
        })
        local item = { Type = "Slider", Bg = bg, Fill = fill, Label = labelText, Min = min, Max = max, Value = default, Step = step, X = barX, Y = barY, W = width, H = 8, Callback = callback, _y = y }
        table.insert(section.items, item)
        return item
    end

    function win:AddDropdown(section, label, options, default, callback)
        section = section or (win._activePage and win._activePage.sections[1])
        if not section then return end
        local y = section._y + (#section.items * 40) + 8
        local x = contentOrigin.X
        local w = win.Size.X - 60
        local h = 24
        local box = newDraw("Square", {
            Color = win.Theme.Panel, Transparency = 1, Filled = true,
            Position = Vector2.new(x + 12, contentOrigin.Y + y), Size = Vector2.new(w, h), Visible = true, ZIndex = win._zIndex + 6
        })
        local labelText = newDraw("Text", {
            Text = label .. ": " .. tostring(default or "<select>"), Color = win.Theme.Text,
            Position = Vector2.new(x + 18, contentOrigin.Y + y + 4), Size = 14, Outline = true, Visible = true, ZIndex = win._zIndex + 7
        })
        local item = {
            Type = "Dropdown", Box = box, Label = labelText, Options = options or {}, Current = default, Expanded = false,
            OptionRects = {}, Callback = callback, X = x + 12, Y = contentOrigin.Y + y, W = w, H = h, _y = y
        }
        table.insert(section.items, item)
        return item
    end

    function win:AddColorPicker(section, label, default, callback)
        section = section or (win._activePage and win._activePage.sections[1])
        if not section then return end
        default = default or win.Theme.Accent
        local r = math.floor(default.R * 255); local g = math.floor(default.G * 255); local b = math.floor(default.B * 255)
        local y = section._y + (#section.items * 92) + 8
        local baseX = contentOrigin.X + 12
        local preview = newDraw("Square", {
            Color = Color3.fromRGB(r,g,b), Transparency = 1, Filled = true,
            Position = Vector2.new(baseX, contentOrigin.Y + y), Size = Vector2.new(48,48), Visible = true, ZIndex = win._zIndex + 7
        })
        local title = newDraw("Text", {
            Text = label, Color = win.Theme.Text, Position = Vector2.new(baseX + 56, contentOrigin.Y + y + 2),
            Size = 15, Outline = true, Visible = true, ZIndex = win._zIndex + 8
        })

        local function makeSlider(offY, lblText, init)
            local bx = baseX + 56
            local by = contentOrigin.Y + y + offY
            local barW = win.Size.X - 120
            local bg = newDraw("Square", { Color = win.Theme.Panel, Transparency = 1, Filled = true, Position = Vector2.new(bx, by), Size = Vector2.new(barW, 8), Visible = true, ZIndex = win._zIndex + 7 })
            local fill = newDraw("Square", { Color = Color3.fromRGB(init,init,init), Transparency = 1, Filled = true, Position = Vector2.new(bx, by), Size = Vector2.new((init/255)*barW, 8), Visible = true, ZIndex = win._zIndex + 8 })
            local lab = newDraw("Text", { Text = lblText .. ": " .. tostring(init), Color = win.Theme.Text, Position = Vector2.new(bx, by - 18), Size = 13, Outline = true, Visible = true, ZIndex = win._zIndex + 9 })
            return { Bg = bg, Fill = fill, Label = lab, X = bx, Y = by, W = barW, Value = init }
        end

        local sR = makeSlider(0, "R", r)
        local sG = makeSlider(28, "G", g)
        local sB = makeSlider(56, "B", b)

        local item = { Type = "ColorPicker", Preview = preview, Title = title, R = sR, G = sG, B = sB, Update = function()
            preview.Color = Color3.fromRGB(sR.Value, sG.Value, sB.Value)
            if callback then pcall(callback, preview.Color) end
        end, _y = y }
        table.insert(section.items, item)
        return item
    end

    function win:AddTextBox(section, placeholder, callback)
        section = section or (win._activePage and win._activePage.sections[1])
        if not section then return end
        local y = section._y + (#section.items * 36) + 8
        local x = contentOrigin.X
        local w = win.Size.X - 60
        local h = 24
        local box = newDraw("Square", {
            Color = win.Theme.Panel, Transparency = 1, Filled = true,
            Position = Vector2.new(x + 12, contentOrigin.Y + y), Size = Vector2.new(w, h), Visible = true, ZIndex = win._zIndex + 6
        })
        local txt = newDraw("Text", {
            Text = placeholder or "", Color = win.Theme.SubText,
            Position = Vector2.new(x + 18, contentOrigin.Y + y + 4), Size = 14, Outline = true, Visible = true, ZIndex = win._zIndex + 7
        })
        local item = { Type = "TextBox", Box = box, Text = txt, Value = "", Placeholder = placeholder or "", Callback = callback, Focus = false, X = x + 12, Y = contentOrigin.Y + y, W = w, H = h, _y = y }
        table.insert(section.items, item)
        return item
    end

    -- Toggle visibility
    function win:Toggle()
        self.Visible = not self.Visible
        if bg then bg.Visible = self.Visible end
        if header then header.Visible = self.Visible end
        if titleText then titleText.Visible = self.Visible end
        if closeText then closeText.Visible = self.Visible end
        for _,t in ipairs(self._tabs) do
            if t.drawRect then t.drawRect.Visible = self.Visible end
            if t.drawText then t.drawText.Visible = self.Visible end
            if t.page then
                for _,s in ipairs(t.page.sections) do
                    if s.headerRect then s.headerRect.Visible = self.Visible end
                    if s.headerText then s.headerText.Visible = self.Visible end
                    for _,it in ipairs(s.items) do
                        if it.Type == "Button" then it.Rect.Visible = self.Visible; it.Text.Visible = self.Visible
                        elseif it.Type == "Toggle" then it.Box.Visible = self.Visible; it.Label.Visible = self.Visible
                        elseif it.Type == "Slider" then it.Bg.Visible = self.Visible; it.Fill.Visible = self.Visible; it.Label.Visible = self.Visible
                        elseif it.Type == "Dropdown" then it.Box.Visible = self.Visible; it.Label.Visible = self.Visible
                            if it.OptionRects then for _,r in ipairs(it.OptionRects) do r.rect.Visible = self.Visible; r.txt.Visible = self.Visible end end
                        elseif it.Type == "ColorPicker" then it.Preview.Visible = self.Visible; it.Title.Visible = self.Visible
                            for _,s in ipairs({it.R, it.G, it.B}) do s.Bg.Visible = self.Visible; s.Fill.Visible = self.Visible; s.Label.Visible = self.Visible end
                        elseif it.Type == "TextBox" then it.Box.Visible = self.Visible; it.Text.Visible = self.Visible end
                    end
                end
            end
        end
    end

    function win:SetTheme(theme)
        for k,v in pairs(theme or {}) do win.Theme[k] = v end
        -- update immediate colors
        if bg then bg.Color = win.Theme.Background end
        if header then header.Color = win.Theme.Panel end
        if titleText then titleText.Color = win.Theme.Text end
        if closeText then closeText.Color = win.Theme.Text end
        -- update tab/button/item colors
        for _,t in ipairs(win._tabs) do
            if t.drawRect then t.drawRect.Color = win.Theme.Panel end
            if t.drawText then t.drawText.Color = win.Theme.Text end
            if t.page then
                for _,s in ipairs(t.page.sections) do
                    if s.headerRect then s.headerRect.Color = win.Theme.Panel end
                    if s.headerText then s.headerText.Color = win.Theme.Text end
                    for _,it in ipairs(s.items) do
                        if it.Type == "Button" then it.Rect.Color = win.Theme.Panel; it.Text.Color = win.Theme.Text
                        elseif it.Type == "Toggle" then it.Box.Color = it.State and win.Theme.Accent or win.Theme.Panel; it.Label.Color = win.Theme.Text
                        elseif it.Type == "Slider" then it.Bg.Color = win.Theme.Panel; it.Fill.Color = win.Theme.Accent; it.Label.Color = win.Theme.Text
                        elseif it.Type == "Dropdown" then it.Box.Color = win.Theme.Panel; it.Label.Color = win.Theme.Text
                            if it.OptionRects then for _,r in ipairs(it.OptionRects) do r.rect.Color = win.Theme.Panel; r.txt.Color = win.Theme.Text end end
                        elseif it.Type == "ColorPicker" then it.Title.Color = win.Theme.Text; it.Preview.Color = it.Preview.Color
                            for _,s in ipairs({it.R, it.G, it.B}) do s.Bg.Color = win.Theme.Panel; s.Fill.Color = Color3.fromRGB(s.Value,s.Value,s.Value); s.Label.Color = win.Theme.Text end
                        elseif it.Type == "TextBox" then it.Box.Color = win.Theme.Panel; it.Text.Color = it.Value == "" and win.Theme.SubText or win.Theme.Text end
                    end
                end
            end
        end
    end

    function win:Destroy()
        self._running = false
        -- remove all drawings belonging to this window by cleaning CreatedDrawings via cleanupAll()
        cleanupAll()
    end

    -- ---------- Input & update loop (polling, uses Player:GetMouse + ismouse1pressed + iskeypressed) ----------
    -- prev key map for edge detection
    local prevKeys = {}
    local prevMouse = false

    -- helper: check key edge
    local function keyDownEdge(vk)
        local cur = (pcall(function() return iskeypressed(vk) end) and iskeypressed(vk)) or false
        local prev = prevKeys[vk] and true or false
        prevKeys[vk] = cur
        return cur and not prev
    end

    -- helper: mouse left edge
    local function mouse1DownEdge()
        local cur = (pcall(function() return ismouse1pressed() end) and ismouse1pressed()) or false
        local prev = prevMouse
        prevMouse = cur
        return cur and not prev
    end

    -- helper for reading current mouse pos (Player:GetMouse())
    local function getMousePos()
        if Mouse and Mouse.X and Mouse.Y then
            return Vector2.new(Mouse.X, Mouse.Y)
        end
        return Vector2.new(0,0)
    end

    -- keyboard char edge detection: append characters when pressed (A-Z,0-9,space,backspace,enter)
    local function pollTextboxTyping(textBox)
        if not textBox then return end
        -- letters A-Z
        for code = 0x41, 0x5A do
            if keyDownEdge(code) then
                local char = string.char(code)
                textBox.Value = (textBox.Value or "") .. char
                textBox.Text.Text = textBox.Value
            end
        end
        -- digits 0-9
        for code = 0x30, 0x39 do
            if keyDownEdge(code) then
                local char = string.char(code)
                textBox.Value = (textBox.Value or "") .. char
                textBox.Text.Text = textBox.Value
            end
        end
        -- space
        if keyDownEdge(VK.SPACE) then
            textBox.Value = (textBox.Value or "") .. " "
            textBox.Text.Text = textBox.Value
        end
        -- backspace
        if keyDownEdge(VK.BACKSPACE) then
            textBox.Value = tostring(textBox.Value or ""):sub(1,-2)
            textBox.Text.Text = textBox.Value == "" and textBox.Placeholder or textBox.Value
        end
        -- enter confirms
        if keyDownEdge(VK.ENTER) then
            if textBox.Callback then pcall(textBox.Callback, textBox.Value) end
            textBox.Focus = false
            win._focusedTextBox = nil
        end
    end

    -- main loop
    win._running = true
    task.spawn(function()
        while win._running do
            -- small sleep, controls responsiveness
            TaskWait(0.025)

            -- basic toggle UI via Delete key edge
            if keyDownEdge(VK.DELETE) then
                win:Toggle()
            end

            if not win.Visible then
                -- still update prev inputs to avoid sticky edges
                prevMouse = (pcall(function() return ismouse1pressed() end) and ismouse1pressed()) or false
                for k,_ in pairs(prevKeys) do prevKeys[k] = (pcall(function() return iskeypressed(k) end) and iskeypressed(k)) or false end
                TaskWait(0.02)
                goto continue
            end

            local mpos = getMousePos()
            local mx, my = mpos.X, mpos.Y
            -- close button hover + click
            local closeHovered = insideRect(win.Position.X + win.Size.X - 28, win.Position.Y + 2, 24, 22, mx, my)
            closeText.Color = closeHovered and win.Theme.Hover or win.Theme.Text
            if mouse1DownEdge() and closeHovered then
                win:Toggle()
            end

            -- header drag start
            local headerHovered = insideRect(win.Position.X, win.Position.Y, win.Size.X, 28, mx, my)
            if mouse1DownEdge() and headerHovered then
                win._dragging = true
                win._dragOffset = Vector2.new(mx - win.Position.X, my - win.Position.Y)
            end
            -- dragging movement
            if (pcall(function() return ismouse1pressed() end) and ismouse1pressed()) and win._dragging then
                win.Position = Vector2.new(mx - win._dragOffset.X, my - win._dragOffset.Y)
                repositionAll()
            else
                win._dragging = false
            end

            -- Tab clicks
            for _,tab in ipairs(win._tabs) do
                local bx = tab.drawRect.Position.X; local by = tab.drawRect.Position.Y
                local bw = tab.drawRect.Size.X; local bh = tab.drawRect.Size.Y
                if insideRect(bx,by,bw,bh, mx, my) and mouse1DownEdge() then
                    -- select this tab's page
                    for _,t2 in ipairs(win._tabs) do if t2.drawRect then t2.drawRect.Color = win.Theme.Panel end end
                    tab.drawRect.Color = win.Theme.Accent
                    win._activePage = tab.page
                end
            end

            -- iterate active page elements
            local page = win._activePage
            if page then
                for _,section in ipairs(page.sections) do
                    for _,it in ipairs(section.items) do
                        if it.Type == "Button" then
                            if insideRect(it.X, it.Y, it.W, it.H, mx, my) then
                                it.Rect.Color = win.Theme.Hover
                                if mouse1DownEdge() and it.Callback then pcall(it.Callback) end
                            else
                                it.Rect.Color = win.Theme.Panel
                            end
                        elseif it.Type == "Toggle" then
                            if insideRect(it.X, it.Y, it.W+150, it.H, mx, my) and mouse1DownEdge() then
                                it.State = not it.State
                                it.Box.Color = it.State and win.Theme.Accent or win.Theme.Panel
                                if it.Callback then pcall(it.Callback, it.State) end
                            end
                        elseif it.Type == "Slider" then
                            if (pcall(function() return ismouse1pressed() end) and ismouse1pressed()) and insideRect(it.X, it.Y-8, it.W, it.H+16, mx, my) then
                                local rel = clamp((mx - it.X) / it.W, 0, 1)
                                local val = it.Min + (it.Max - it.Min) * rel
                                -- snap to step
                                if it.Step and it.Step > 0 then
                                    val = math.floor(val / it.Step + 0.5) * it.Step
                                end
                                it.Value = val
                                it.Fill.Size = Vector2.new(it.W * clamp((it.Value - it.Min)/(it.Max - it.Min), 0, 1), it.Fill.Size.Y)
                                it.Label.Text = (it.Label.Text:match("^[^:]+:") or "") .. " " .. tostring(math.floor(it.Value + 0.5))
                                if it.Callback then pcall(it.Callback, it.Value) end
                            end
                        elseif it.Type == "Dropdown" then
                            if insideRect(it.X, it.Y, it.W, it.H, mx, my) and mouse1DownEdge() then
                                if it.Expanded then
                                    -- collapse & remove option rects
                                    if it.OptionRects then
                                        for _,r in ipairs(it.OptionRects) do removeDraw(r.rect); removeDraw(r.txt) end
                                        it.OptionRects = nil
                                    end
                                    it.Expanded = false
                                else
                                    -- expand
                                    it.OptionRects = it.OptionRects or {}
                                    for idx,opt in ipairs(it.Options) do
                                        local oy = it.Box.Position.Y + idx*26
                                        local r = newDraw("Square", { Color = win.Theme.Panel, Transparency = 1, Filled = true, Position = Vector2.new(it.Box.Position.X, oy), Size = Vector2.new(it.W, 24), Visible = true, ZIndex = win._zIndex + 8 })
                                        local t = newDraw("Text", { Text = tostring(opt), Color = win.Theme.Text, Position = Vector2.new(it.Box.Position.X + 6, oy + 4), Size = 14, Outline = true, Visible = true, ZIndex = win._zIndex + 9 })
                                        table.insert(it.OptionRects, { rect = r, txt = t, value = opt, oy = oy })
                                    end
                                    it.Expanded = true
                                end
                            end
                            -- if expanded, handle option clicks
                            if it.Expanded and it.OptionRects then
                                for _,orow in ipairs(it.OptionRects) do
                                    if insideRect(orow.rect.Position.X, orow.rect.Position.Y, orow.rect.Size.X, orow.rect.Size.Y, mx, my) and mouse1DownEdge() then
                                        it.Current = orow.value
                                        it.Label.Text = (it.Label.Text:match("^[^:]+:") or "") .. ": " .. tostring(it.Current)
                                        if it.Callback then pcall(it.Callback, it.Current) end
                                        -- collapse and remove rects
                                        for _,r in ipairs(it.OptionRects) do removeDraw(r.rect); removeDraw(r.txt) end
                                        it.OptionRects = nil
                                        it.Expanded = false
                                        break
                                    end
                                end
                            end
                        elseif it.Type == "ColorPicker" then
                            -- each sub-slider
                            for _,sl in ipairs({it.R, it.G, it.B}) do
                                if (pcall(function() return ismouse1pressed() end) and ismouse1pressed()) and insideRect(sl.X, sl.Y, sl.W, 12, mx, my) then
                                    local rel = clamp((mx - sl.X) / sl.W, 0, 1)
                                    sl.Value = math.floor(rel * 255)
                                    sl.Fill.Size = Vector2.new(sl.W * rel, sl.Fill.Size.Y)
                                    sl.Label.Text = (sl.Label.Text:match("^[^:]+:") or "") .. " " .. tostring(sl.Value)
                                    it.Preview.Color = Color3.fromRGB(it.R.Value, it.G.Value, it.B.Value)
                                    if it.Update then pcall(it.Update) end
                                end
                            end
                        elseif it.Type == "TextBox" then
                            -- click to focus
                            if insideRect(it.X, it.Y, it.W, it.H, mx, my) and mouse1DownEdge() then
                                -- focus this textbox
                                for _,p in ipairs(win._pages) do end
                                it.Focus = true
                                win._focusedTextBox = it
                                it.Text.Color = win.Theme.Text
                                it.Text.Text = it.Value ~= "" and it.Value or ""
                            end
                        end
                    end
                end
            end

            -- handle typing for focused textbox
            if win._focusedTextBox then pollTextboxTyping(win._focusedTextBox) end

            ::continue::
        end
    end)

    -- return API for created window
    local API = {}
    function API:AddTab(name) return win:AddTab(name) end
    function API:AddSection(page,title) return win:AddSection(page,title) end
    function API:AddButton(section,label,cb) return win:AddButton(section,label,cb) end
    function API:AddToggle(section,label,default,cb) return win:AddToggle(section,label,default,cb) end
    function API:AddSlider(section,label,min,max,default,step,cb) return win:AddSlider(section,label,min,max,default,step,cb) end
    function API:AddDropdown(section,label,options,default,cb) return win:AddDropdown(section,label,options,default,cb) end
    function API:AddColorPicker(section,label,default,cb) return win:AddColorPicker(section,label,default,cb) end
    function API:AddTextBox(section,placeholder,cb) return win:AddTextBox(section,placeholder,cb) end
    function API:SetTheme(t) win:SetTheme(t) end
    function API:Toggle() win:Toggle() end
    function API:Destroy() win:Destroy() end

    -- also expose internal window for more control
    API._internal = win

    return API
end

-- return library table
-- Make it callable: MatchaLinoria:CreateWindow(...)
local Library = {}
Library.__index = Library
setmetatable(Library, { __index = MatchaLinoria })
function Library:CreateWindow(opts) return MatchaLinoria:CreateWindow(opts) end

-- ========== Showcase (using library we just built) ==========
local UI = Library
local win = UI:CreateWindow({ Title = "MatchaLinoria Demo", Size = Vector2.new(620,420), Position = Vector2.new(220, 90) })

-- build tabs/pages/sections
local mainPage = win:AddTab("Main")
local advPage = win:AddTab("Advanced")
local setPage = win:AddTab("Settings")

local mainSection = win:AddSection(mainPage, "General")
local advSection = win:AddSection(advPage, "Visuals")
local setSection = win:AddSection(setPage, "Controls")

-- Buttons
win:AddButton(mainSection, "Say Hello", function() printl("[Demo] Hello!") end)
win:AddButton(mainSection, "Timestamp", function() printl("[Demo] " .. os.date("%Y-%m-%d %H:%M:%S")) end)

-- Toggles
win:AddToggle(mainSection, "Enable Feature", false, function(s) printl("[Demo] Feature:", s) end)
win:AddToggle(mainSection, "Auto Print", true, function(s) printl("[Demo] AutoPrint:", s) end)

-- Slider
win:AddSlider(mainSection, "Power", 0, 100, 42, 1, function(v) printl("[Demo] Power ->", math.floor(v + 0.5)) end)

-- Dropdown
win:AddDropdown(advSection, "Mode", {"Stealth","Aggressive","Support","Custom"}, "Stealth", function(c) printl("[Demo] Mode:", c) end)

-- Color picker
local cp = win:AddColorPicker(advSection, "Accent", Color3.fromRGB(0,150,255), function(c) printl("[Demo] Color:", c) end)

-- Textbox
local tb = win:AddTextBox(setSection, "Enter name...", function(txt) printl("[Demo] Name entered:", txt) end)

printl("[MatchaLinoria] Demo loaded. Press Delete to toggle UI visibility.")
return Library
