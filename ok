-- MatchaRayfield (Linoria-style) â€” Drawing-based UI for Matcha LuaVM
-- Author: ChatGPT (adapted for your Drawing API)
-- Paste and run in your VM (requires Drawing.new & game services)

-- ===== Environment helpers =====
local Players = (pcall(function() return game:GetService("Players") end) and game:GetService("Players")) or nil
local LocalPlayer = Players and Players.LocalPlayer
local Mouse = nil
if LocalPlayer and pcall(function() return LocalPlayer.GetMouse end) then
    Mouse = LocalPlayer:GetMouse()
else
    -- Minimal fallback mouse-like table (won't do clicks)
    Mouse = { X = 0, Y = 0, Button1Down = false }
end

local UserInputService = (pcall(function() return game:GetService("UserInputService") end) and game:GetService("UserInputService")) or nil
local RunService = (pcall(function() return game:GetService("RunService") end) and game:GetService("RunService")) or nil
local task_wait = task and task.wait or wait

-- ===== Theme (Linoria-style) =====
local Theme = {
    Background = Color3.fromRGB(26,26,28),
    Panel = Color3.fromRGB(34,34,36),
    Accent = Color3.fromRGB(0, 150, 255),
    Text = Color3.fromRGB(230,230,230),
    SubText = Color3.fromRGB(160,160,160),
    Hover = Color3.fromRGB(46,46,48),
    Disabled = Color3.fromRGB(60,60,62)
}

-- ===== Drawing helpers =====
local Created = {} -- keep references for cleanup
local function createDrawing(kind, props)
    local ok, obj = pcall(function() return Drawing.new(kind) end)
    if not ok or not obj then return nil end
    for k,v in pairs(props or {}) do
        pcall(function() obj[k] = v end)
    end
    table.insert(Created, obj)
    return obj
end

local function removeDrawing(obj)
    if not obj then return end
    pcall(function() obj:Remove() end)
    for i,v in ipairs(Created) do
        if v == obj then table.remove(Created, i); break end
    end
end

-- clamp helper
local function clamp(n,a,b) return math.max(a, math.min(b, n)) end

-- simple click detection
local function isMouseInRect(x,y,w,h)
    return Mouse and Mouse.X >= x and Mouse.X <= x + w and Mouse.Y >= y and Mouse.Y <= y + h
end

-- ===== UI core =====
local UI = {}
UI.__index = UI

function UI:Destroy()
    -- remove all drawings
    for _,d in ipairs(Created) do
        pcall(function() d:Remove() end)
    end
    Created = {}
    -- stop loops if needed
    self._running = false
end

-- Create a window
function UI.NewWindow(opts)
    opts = opts or {}
    local title = opts.Title or "MatchaRayfield (Linoria)"
    local pos = opts.Position or Vector2.new(150, 120)
    local size = opts.Size or Vector2.new(520, 380)
    local win = setmetatable({}, UI)
    win.Position = pos
    win.Size = size
    win.Title = title
    win.Visible = true
    win._elements = {} -- store elements for layout & interaction
    win._dragging = false
    win._dragOffset = Vector2.new(0,0)
    win._focusedTextbox = nil

    -- Create background panel
    win._bg = createDrawing("Square", {
        Color = Theme.Background,
        Transparency = 1,
        Size = size,
        Position = pos,
        Filled = true,
        Visible = true,
        ZIndex = 1
    })

    -- Header bar
    win._header = createDrawing("Square", {
        Color = Theme.Panel,
        Transparency = 1,
        Size = Vector2.new(size.X, 28),
        Position = Vector2.new(pos.X, pos.Y),
        Filled = true,
        Visible = true,
        ZIndex = 2
    })

    -- Title text
    win._title = createDrawing("Text", {
        Text = title,
        Color = Theme.Text,
        Position = Vector2.new(pos.X + 10, pos.Y + 5),
        Size = 18,
        Outline = true,
        Visible = true,
        ZIndex = 3
    })

    -- close button (simple X)
    win._close = createDrawing("Text", {
        Text = "X",
        Color = Theme.Text,
        Position = Vector2.new(pos.X + size.X - 24, pos.Y + 4),
        Size = 18,
        Outline = true,
        Visible = true,
        ZIndex = 3
    })

    -- tabs container (we'll draw buttons)
    win._tabButtons = {}
    win._pages = {}
    win._activePage = nil

    -- layout cursor inside content
    win._contentOrigin = Vector2.new(pos.X + 10, pos.Y + 38)
    win._cursorY = 0

    -- input tracking state
    win._mousePrevDown = false

    -- make window draggable (by header)
    local function headerInputLoop()
        -- we will update dragging state inside global render/update loop
    end

    -- addTab function
    function win:AddTab(name)
        local index = #win._tabButtons + 1
        local btnX = win.Position.X + 8 + (index - 1) * 100
        local btnPos = Vector2.new(btnX, win.Position.Y + 32)
        local btnSize = Vector2.new(92, 20)

        -- draw tab button rect & text
        local btnRect = createDrawing("Square", {
            Color = Theme.Panel,
            Transparency = 1,
            Size = btnSize,
            Position = btnPos,
            Filled = true,
            Visible = true,
            ZIndex = 4
        })
        local btnText = createDrawing("Text", {
            Text = name,
            Color = Theme.Text,
            Position = Vector2.new(btnPos.X + 8, btnPos.Y + 2),
            Size = 14,
            Outline = true,
            Visible = true,
            ZIndex = 5
        })

        -- page container (logical)
        local page = { Elements = {}, Name = name }
        win._pages[name] = page

        -- click handler
        table.insert(win._tabButtons, { Rect = btnRect, Text = btnText, Name = name, Page = page })

        -- auto-select first
        if not win._activePage then
            win._activePage = page
            btnRect.Color = Theme.Accent
        end

        return page
    end

    -- Adds a section (visual grouping) to a page
    function win:AddSection(page, title)
        page = page or win._activePage
        local section = { Items = {}, Title = title }
        -- compute Y
        local y = win._cursorY
        -- draw section header
        local headerRect = createDrawing("Square", {
            Color = Theme.Panel,
            Transparency = 1,
            Size = Vector2.new(win.Size.X - 20, 26),
            Position = Vector2.new(win._contentOrigin.X, win._contentOrigin.Y + y),
            Filled = true,
            Visible = true,
            ZIndex = 4
        })
        local headerText = createDrawing("Text", {
            Text = title,
            Color = Theme.Text,
            Position = Vector2.new(win._contentOrigin.X + 8, win._contentOrigin.Y + y + 4),
            Size = 16,
            Outline = true,
            Visible = true,
            ZIndex = 5
        })
        y = y + 34
        section._headerRect = headerRect
        section._headerText = headerText
        section._yOffset = y
        section._origin = Vector2.new(win._contentOrigin.X, win._contentOrigin.Y)
        table.insert(page.Elements, section)
        -- advance cursor
        win._cursorY = y + 6
        return section
    end

    -- Add Button to section
    function win:AddButton(section, label, callback)
        section = section or (win._activePage and win._activePage.Elements[1]) -- fallback
        local y = section._yOffset + (#section.Items * 34)
        local x = section._origin.X
        local w = win.Size.X - 40
        local h = 28
        local rect = createDrawing("Square", {
            Color = Theme.Panel,
            Transparency = 1,
            Size = Vector2.new(w, h),
            Position = Vector2.new(x + 6, win._contentOrigin.Y + y),
            Filled = true,
            Visible = true,
            ZIndex = 6
        })
        local txt = createDrawing("Text", {
            Text = label,
            Color = Theme.Text,
            Position = Vector2.new(x + 12, win._contentOrigin.Y + y + 6),
            Size = 15,
            Outline = true,
            Visible = true,
            ZIndex = 7
        })
        local item = { Type = "Button", Rect = rect, Text = txt, X = x + 6, Y = win._contentOrigin.Y + y, W = w, H = h, Callback = callback }
        table.insert(section.Items, item)
        win._cursorY = win._cursorY + 34
        return item
    end

    -- Add Toggle to section
    function win:AddToggle(section, label, default, callback)
        section = section or (win._activePage and win._activePage.Elements[1])
        local y = section._yOffset + (#section.Items * 34)
        local x = section._origin.X
        local boxSize = 20
        local box = createDrawing("Square", {
            Color = default and Theme.Accent or Theme.Panel,
            Transparency = 1,
            Size = Vector2.new(boxSize, boxSize),
            Position = Vector2.new(x + 8, win._contentOrigin.Y + y + 4),
            Filled = true,
            Visible = true,
            ZIndex = 6
        })
        local txt = createDrawing("Text", {
            Text = label,
            Color = Theme.Text,
            Position = Vector2.new(x + 8 + boxSize + 8, win._contentOrigin.Y + y + 4),
            Size = 15,
            Outline = true,
            Visible = true,
            ZIndex = 7
        })
        local state = default and true or false
        local item = { Type = "Toggle", Box = box, Text = txt, State = state, X = x + 8, Y = win._contentOrigin.Y + y + 4, W = boxSize, H = boxSize, Callback = callback }
        table.insert(section.Items, item)
        win._cursorY = win._cursorY + 30
        return item
    end

    -- Add Slider (horizontal)
    function win:AddSlider(section, label, min, max, default, callback)
        section = section or (win._activePage and win._activePage.Elements[1])
        min = min or 0; max = max or 100; default = default or min
        local y = section._yOffset + (#section.Items * 46)
        local x = section._origin.X
        local width = win.Size.X - 60
        local barH = 8
        local barX = x + 12
        local barY = win._contentOrigin.Y + y + 18

        local backgroundBar = createDrawing("Square", {
            Color = Theme.Panel,
            Transparency = 1,
            Size = Vector2.new(width, barH),
            Position = Vector2.new(barX, barY),
            Filled = true,
            Visible = true,
            ZIndex = 6
        })

        local fillPct = clamp((default - min) / (max - min), 0, 1)
        local fillBar = createDrawing("Square", {
            Color = Theme.Accent,
            Transparency = 1,
            Size = Vector2.new(width * fillPct, barH),
            Position = Vector2.new(barX, barY),
            Filled = true,
            Visible = true,
            ZIndex = 7
        })

        local labelText = createDrawing("Text", {
            Text = label .. " : " .. tostring(default),
            Color = Theme.Text,
            Position = Vector2.new(barX, barY - 18),
            Size = 14,
            Outline = true,
            Visible = true,
            ZIndex = 7
        })

        local value = default
        local dragging = false

        local item = {
            Type = "Slider",
            Bg = backgroundBar,
            Fill = fillBar,
            Label = labelText,
            Min = min, Max = max, Value = value,
            X = barX, Y = barY, W = width, H = barH,
            Drag = false,
            Callback = callback
        }

        table.insert(section.Items, item)
        win._cursorY = win._cursorY + 46
        return item
    end

    -- Add Dropdown
    function win:AddDropdown(section, label, options, default, callback)
        section = section or (win._activePage and win._activePage.Elements[1])
        local y = section._yOffset + (#section.Items * 40)
        local x = section._origin.X
        local w = win.Size.X - 60
        local h = 24

        local box = createDrawing("Square", {
            Color = Theme.Panel,
            Transparency = 1,
            Size = Vector2.new(w, h),
            Position = Vector2.new(x + 12, win._contentOrigin.Y + y),
            Filled = true,
            Visible = true,
            ZIndex = 6
        })

        local labelText = createDrawing("Text", {
            Text = label .. ": " .. (default or "<select>"),
            Color = Theme.Text,
            Position = Vector2.new(x + 18, win._contentOrigin.Y + y + 4),
            Size = 14,
            Outline = true,
            Visible = true,
            ZIndex = 7
        })

        local expanded = false
        local optionRects = {}
        local current = default

        local item = {
            Type = "Dropdown",
            Box = box, Label = labelText,
            Options = options, Current = current, Expanded = expanded,
            X = x + 12, Y = win._contentOrigin.Y + y, W = w, H = h, Callback = callback
        }

        function item:ToggleExpand()
            if self.Expanded then
                -- remove option drawings
                for _,r in ipairs(optionRects) do removeDrawing(r.rect); removeDrawing(r.txt) end
                optionRects = {}
                self.Expanded = false
            else
                -- create option drawings
                for i,opt in ipairs(self.Options) do
                    local oy = self.Y + i * 26
                    local r = createDrawing("Square", {
                        Color = Theme.Panel,
                        Transparency = 1,
                        Size = Vector2.new(self.W, 24),
                        Position = Vector2.new(self.X, oy),
                        Filled = true,
                        Visible = true,
                        ZIndex = 6
                    })
                    local t = createDrawing("Text", {
                        Text = tostring(opt),
                        Color = Theme.Text,
                        Position = Vector2.new(self.X + 6, oy + 4),
                        Size = 14,
                        Outline = true,
                        Visible = true,
                        ZIndex = 7
                    })
                    table.insert(optionRects, {rect = r, txt = t, value = opt, oy = oy})
                end
                self.Expanded = true
            end
        end

        table.insert(section.Items, item)
        win._cursorY = win._cursorY + 36
        return item
    end

    -- Add Color Picker (RGB sliders)
    function win:AddColorPicker(section, label, default, callback)
        section = section or (win._activePage and win._activePage.Elements[1])
        default = default or Color3.fromRGB(Theme.Accent.R*255, Theme.Accent.G*255, Theme.Accent.B*255)
        local r = math.floor(default.R * 255); local g = math.floor(default.G * 255); local b = math.floor(default.B * 255)
        local lbl = label or "Color"
        local y = section._yOffset + (#section.Items * 90)
        local baseX = section._origin.X + 12

        local preview = createDrawing("Square", {
            Color = default,
            Transparency = 1,
            Size = Vector2.new(48,48),
            Position = Vector2.new(baseX, win._contentOrigin.Y + y),
            Filled = true,
            Visible = true,
            ZIndex = 7
        })
        local title = createDrawing("Text", {
            Text = lbl,
            Color = Theme.Text,
            Position = Vector2.new(baseX + 56, win._contentOrigin.Y + y + 2),
            Size = 15,
            Outline = true,
            Visible = true,
            ZIndex = 8
        })

        local function makeRGBSlider(offsetY, labelText, initVal)
            local barW = win.Size.X - 120
            local bx = baseX + 56
            local by = win._contentOrigin.Y + y + offsetY
            local bg = createDrawing("Square", {
                Color = Theme.Panel, Transparency = 1,
                Size = Vector2.new(barW, 8), Position = Vector2.new(bx, by), Filled = true, Visible = true, ZIndex = 7
            })
            local fill = createDrawing("Square", {
                Color = Color3.fromRGB(initVal, initVal, initVal), Transparency = 1,
                Size = Vector2.new((initVal/255)*barW, 8), Position = Vector2.new(bx, by), Filled = true, Visible = true, ZIndex = 8
            })
            local lab = createDrawing("Text", { Text = labelText .. ": " .. tostring(initVal), Color = Theme.Text, Position = Vector2.new(bx, by - 18), Size = 13, Outline = true, Visible = true, ZIndex = 9 })
            return { Bg = bg, Fill = fill, Label = lab, X = bx, Y = by, W = barW, Value = initVal }
        end

        local sR = makeRGBSlider(0, "R", r)
        local sG = makeRGBSlider(28, "G", g)
        local sB = makeRGBSlider(56, "B", b)

        -- update preview helper
        local function updatePreview()
            preview.Color = Color3.fromRGB(sR.Value, sG.Value, sB.Value)
            if callback then pcall(callback, preview.Color) end
        end

        local item = { Type = "ColorPicker", Preview = preview, R = sR, G = sG, B = sB, Update = updatePreview }
        table.insert(section.Items, item)
        win._cursorY = win._cursorY + 92
        return item
    end

    -- Add TextBox (captures keyboard input)
    function win:AddTextBox(section, placeholder, callback)
        section = section or (win._activePage and win._activePage.Elements[1])
        local y = section._yOffset + (#section.Items * 34)
        local x = section._origin.X
        local w = win.Size.X - 60
        local h = 24
        local box = createDrawing("Square", {
            Color = Theme.Panel,
            Size = Vector2.new(w, h),
            Position = Vector2.new(x + 12, win._contentOrigin.Y + y),
            Filled = true,
            Visible = true,
            ZIndex = 6
        })
        local txt = createDrawing("Text", {
            Text = placeholder or "",
            Color = Theme.SubText,
            Position = Vector2.new(x + 18, win._contentOrigin.Y + y + 4),
            Size = 14,
            Outline = true,
            Visible = true,
            ZIndex = 7
        })
        local textValue = ""
        local focused = false
        local item = { Type = "TextBox", Box = box, Text = txt, Value = textValue, Focus = focused, Callback = callback, X = x + 12, Y = win._contentOrigin.Y + y, W = w, H = h }
        table.insert(section.Items, item)
        win._cursorY = win._cursorY + 34

        -- Input handling: focus on click; keyboard via UserInputService
        return item
    end

    -- store ui into global for loops
    win._running = true
    -- Add an update loop that handles input & redraw interactive states
    local function step()
        -- header dragging + detect header clicks to drag or close
        -- update header hover & close hover
        local mx, my = Mouse.X, Mouse.Y
        local posX, posY = win.Position.X, win.Position.Y
        -- header hover
        local headerHovered = isMouseInRect(posX, posY, win.Size.X, 28)
        win._header.Color = headerHovered and Theme.Hover or Theme.Panel
        -- close hover
        local closeHovered = isMouseInRect(posX + win.Size.X - 30, posY + 2, 26, 24)
        win._close.Color = closeHovered and Theme.Hover or Theme.Text

        -- close click
        if Mouse.Button1Down and not win._mousePrevDown and closeHovered then
            -- toggle visibility
            win.Visible = not win.Visible
            win._bg.Visible = win.Visible
            win._header.Visible = win.Visible
            win._title.Visible = win.Visible
            win._close.Visible = win.Visible
            for _,btn in ipairs(win._tabButtons) do btn.Rect.Visible = win.Visible; btn.Text.Visible = win.Visible end
            for _,page in pairs(win._pages) do
                for _,s in ipairs(page.Elements) do
                    if s._headerRect then s._headerRect.Visible = win.Visible end
                    if s._headerText then s._headerText.Visible = win.Visible end
                    for _,it in ipairs(s.Items) do
                        -- set visible for item components conservatively
                        if it.Rect then it.Rect.Visible = win.Visible end
                        if it.Text then it.Text.Visible = win.Visible end
                        if it.Box then it.Box.Visible = win.Visible end
                        if it.Label then it.Label.Visible = win.Visible end
                        if it.Bg then it.Bg.Visible = win.Visible end
                        if it.Fill then it.Fill.Visible = win.Visible end
                        if it.Preview then it.Preview.Visible = win.Visible end
                        if it.Txt then it.Txt.Visible = win.Visible end
                    end
                end
            end
        end

        -- dragging start
        if Mouse.Button1Down and headerHovered and not win._mousePrevDown then
            win._dragging = true
            win._dragOffset = Vector2.new(Mouse.X - win.Position.X, Mouse.Y - win.Position.Y)
        end
        -- dragging end
        if not Mouse.Button1Down and win._dragging then
            win._dragging = false
        end
        -- dragging move
        if win._dragging then
            win.Position = Vector2.new(Mouse.X - win._dragOffset.X, Mouse.Y - win._dragOffset.Y)
            -- move header/bg/title/close/tab buttons/content elements by displacement
            win._bg.Position = win.Position
            win._header.Position = Vector2.new(win.Position.X, win.Position.Y)
            win._title.Position = Vector2.new(win.Position.X + 10, win.Position.Y + 5)
            win._close.Position = Vector2.new(win.Position.X + win.Size.X - 24, win.Position.Y + 4)
            -- update tab button positions
            for i,btn in ipairs(win._tabButtons) do
                local bx = win.Position.X + 8 + (i - 1) * 100
                btn.Rect.Position = Vector2.new(bx, win.Position.Y + 32)
                btn.Text.Position = Vector2.new(bx + 8, win.Position.Y + 34)
            end
            -- update section positions & items (simple approach: reposition everything based on content origin)
            win._contentOrigin = Vector2.new(win.Position.X + 10, win.Position.Y + 38)
            for _,page in pairs(win._pages) do
                for sIndex,s in ipairs(page.Elements) do
                    local sy = 0
                    if s._headerRect then
                        s._headerRect.Position = Vector2.new(win._contentOrigin.X, win._contentOrigin.Y + s._yOffset - (win._cursorY - s._yOffset))
                        s._headerText.Position = Vector2.new(win._contentOrigin.X + 8, win._contentOrigin.Y + s._yOffset - (win._cursorY - s._yOffset) + 4)
                    end
                    for i,it in ipairs(s.Items) do
                        if it.Type == "Button" then
                            it.Rect.Position = Vector2.new(win._contentOrigin.X + 6, s._origin.Y + (s._yOffset - s._yOffset) + (i-1)*34 + (win._contentOrigin.Y - s._origin.Y))
                            it.Text.Position = Vector2.new(win._contentOrigin.X + 12, s._origin.Y + (s._yOffset - s._yOffset) + (i-1)*34 + (win._contentOrigin.Y - s._origin.Y) + 6)
                        end
                    end
                end
            end
        end

        -- Tab click handling
        for _,btn in ipairs(win._tabButtons) do
            local bx,by = btn.Rect.Position.X, btn.Rect.Position.Y
            local bw,bh = btn.Rect.Size.X, btn.Rect.Size.Y
            if isMouseInRect(bx,by,bw,bh) and Mouse.Button1Down and not win._mousePrevDown then
                -- select
                for _,b2 in ipairs(win._tabButtons) do b2.Rect.Color = Theme.Panel end
                btn.Rect.Color = Theme.Accent
                win._activePage = btn.Page
            end
        end

        -- iterate active page items and handle click/drag/keyboard
        if win._activePage then
            for _,section in ipairs(win._activePage.Elements) do
                for _,item in ipairs(section.Items) do
                    if item.Type == "Button" then
                        if isMouseInRect(item.X, item.Y, item.W, item.H) then
                            item.Rect.Color = Theme.Hover
                            if Mouse.Button1Down and not win._mousePrevDown then
                                pcall(item.Callback)
                                -- flash
                                item.Rect.Color = Theme.Accent
                                task_wait(0.08)
                                item.Rect.Color = Theme.Panel
                            end
                        else
                            item.Rect.Color = Theme.Panel
                        end
                    elseif item.Type == "Toggle" then
                        if isMouseInRect(item.X, item.Y, item.W + 120, item.H) and Mouse.Button1Down and not win._mousePrevDown then
                            item.State = not item.State
                            item.Box.Color = item.State and Theme.Accent or Theme.Panel
                            if item.Callback then pcall(item.Callback, item.State) end
                        end
                    elseif item.Type == "Slider" then
                        -- dragging slider
                        if Mouse.Button1Down and isMouseInRect(item.X, item.Y - 8, item.W, item.H + 16) then
                            local rel = clamp((Mouse.X - item.X) / item.W, 0, 1)
                            item.Value = math.floor(item.Min + (item.Max - item.Min) * rel + 0.5)
                            item.Fill.Size = Vector2.new(item.W * clamp((item.Value - item.Min)/(item.Max - item.Min),0,1), item.Fill.Size.Y)
                            item.Label.Text = item.Label.Text:match("^[^:]+:") .. " " .. tostring(item.Value)
                            if item.Callback then pcall(item.Callback, item.Value) end
                        end
                    elseif item.Type == "Dropdown" then
                        -- box click toggles expand
                        if isMouseInRect(item.X, item.Y, item.W, item.H) and Mouse.Button1Down and not win._mousePrevDown then
                            if item.Expanded then item:ToggleExpand() else item:ToggleExpand() end
                        end
                        -- check options if expanded
                        if item.Expanded then
                            for _,r in ipairs(Created) do
                                -- handled by optionRects stored per item via item. ToggleExpand. Simpler: check global created objects near the area
                            end
                            -- We can't easily map created objects back without storing - but we stored optionRects inside item via ToggleExpand closure; handle clicks by iterating Created and checking Y positions:
                            -- Simpler approach: re-walk optionRects if present
                            if item.Expanded and item.Options then
                                for i,opt in ipairs(item.Options) do
                                    local oy = item.Y + i*26
                                    if isMouseInRect(item.X, oy, item.W, 24) and Mouse.Button1Down and not win._mousePrevDown then
                                        item.Current = opt
                                        item.Label.Text = (item.Label.Text:match("^[^:]+:") or "") .. ": " .. tostring(opt)
                                        if item.Callback then pcall(item.Callback, opt) end
                                        -- collapse by removing all Expanded rects text entries (we didn't keep references here to avoid overcomplicating)
                                        -- Instead, set Expanded = false and rely on UX (option drawings are persistent until toggled off via ToggleExpand earlier)
                                        item.Expanded = false
                                    end
                                end
                            end
                        end
                    elseif item.Type == "ColorPicker" then
                        -- rgb sliders
                        for _,s in ipairs({item.R, item.G, item.B}) do
                            if Mouse.Button1Down and isMouseInRect(s.X, s.Y, s.W, 12) then
                                local rel = clamp((Mouse.X - s.X) / s.W, 0, 1)
                                s.Value = math.floor(rel * 255)
                                s.Fill.Size = Vector2.new(s.W * rel, s.Fill.Size.Y)
                                s.Label.Text = s.Label.Text:match("^[^:]+:") .. " " .. tostring(s.Value)
                                item.Preview.Color = Color3.fromRGB(item.R.Value, item.G.Value, item.B.Value)
                                if item.Update then pcall(item.Update) end
                            end
                        end
                    elseif item.Type == "TextBox" then
                        -- click to focus
                        if isMouseInRect(item.X, item.Y, item.W, item.H) and Mouse.Button1Down and not win._mousePrevDown then
                            -- toggle focus
                            item.Focus = true
                            win._focusedTextbox = item
                            item.Text.Color = Theme.Text
                        end
                    end
                end
            end
        end

        -- keyboard input for focused textbox
        if UserInputService and win._focusedTextbox then
            -- handled by InputBegan below (we hook once)
        end

        win._mousePrevDown = Mouse.Button1Down
    end

    -- Hook keyboard for textbox
    if UserInputService then
        UserInputService.InputBegan:Connect(function(input, gameProcessed)
            if gameProcessed then return end
            if win._focusedTextbox and input.UserInputType == Enum.UserInputType.Keyboard then
                local key = input.KeyCode and input.KeyCode.Name or tostring(input.KeyCode)
                -- printable letters/numbers
                if input.KeyCode == Enum.KeyCode.Backspace then
                    win._focusedTextbox.Value = tostring(win._focusedTextbox.Value):sub(1, -2)
                    win._focusedTextbox.Text.Text = win._focusedTextbox.Value ~= "" and win._focusedTextbox.Value or ""
                elseif input.KeyCode == Enum.KeyCode.Return or input.KeyCode == Enum.KeyCode.Escape then
                    -- finalize
                    if win._focusedTextbox.Callback then pcall(win._focusedTextbox.Callback, win._focusedTextbox.Value) end
                    win._focusedTextbox.Focus = false
                    win._focusedTextbox = nil
                else
                    -- Input.Text property not available in all envs; try input.KeyCode.Name for alnum (simple)
                    local char = input.KeyCode.Name
                    -- map A-Z and 0-9
                    if #char == 1 then
                        win._focusedTextbox.Value = (win._focusedTextbox.Value or "") .. char
                        win._focusedTextbox.Text.Text = win._focusedTextbox.Value
                    else
                        -- ignore other keys
                    end
                end
            end
        end)
    end

    -- Run loop
    if RunService and RunService.RenderStepped then
        RunService:BindToRenderStep("MatchaRayfieldRender"..tostring(math.random(1,99999)), Enum.RenderPriority.Last.Value, function()
            if not win._running then return end
            step()
        end)
    else
        -- fallback polling loop
        spawn(function()
            while win._running do step(); task_wait(0.03) end
        end)
    end

    return win
end

-- ========== Showcase ==========

local window = UI.NewWindow({Title = "MatchaRayfield - Linoria Demo", Position = Vector2.new(220,90), Size = Vector2.new(600,420)})

local main = window:AddTab("Main")
local adv = window:AddTab("Advanced")
local settings = window:AddTab("Settings")

-- Main tab content
local s1 = window:AddSection(main, "Interactive")
window:AddButton(s1, "Say Hello", function() print("Hello from Linoria-style drawing UI!") end)
local tog = window:AddToggle(s1, "Enable Feature", false, function(state) print("Toggle changed:", state) end)
local slider = window:AddSlider(s1, "Power", 0, 100, 40, function(v) print("Slider:", v) end)

-- Advanced
local s2 = window:AddSection(adv, "Visuals")
local dropdown = window:AddDropdown(s2, "Mode", {"Stealth","Aggressive","Support"}, "Stealth", function(choice) print("Dropdown ->", choice) end)
local cp = window:AddColorPicker(s2, "Accent Color", Color3.fromRGB(0,150,255), function(c) print("Color ->", c) end)
local tb = window:AddTextBox(s2, "Name...", function(txt) print("TextBox confirmed:", txt) end)

-- Settings
local s3 = window:AddSection(settings, "Options")
window:AddButton(s3, "Apply Accent", function()
    if cp and cp.Preview then
        local c = cp.Preview.Color
        Theme.Accent = c
        print("Applied accent to theme:", c)
    end
end)

print("MatchaRayfield Linoria demo loaded (Drawing-based).")
